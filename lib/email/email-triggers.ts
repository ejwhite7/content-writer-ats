import { EmailService } from './email-service'\nimport { createClient } from '@/lib/supabase/server'\n\nexport class EmailTriggers {\n  private emailService: EmailService\n  private supabase = createClient()\n\n  constructor() {\n    this.emailService = new EmailService()\n  }\n\n  async onApplicationSubmitted(applicationId: string) {\n    try {\n      // Get application details\n      const { data: application, error } = await this.supabase\n        .from('applications')\n        .select(`\n          *,\n          jobs (title, tenant_id),\n          users (first_name, last_name, email),\n          tenants (name)\n        `)\n        .eq('id', applicationId)\n        .single()\n\n      if (error || !application) {\n        console.error('Error fetching application for email:', error)\n        return\n      }\n\n      const context = {\n        candidateName: `${application.users.first_name} ${application.users.last_name}`,\n        jobTitle: application.jobs.title,\n        companyName: application.tenants.name,\n        applicationUrl: `${process.env.NEXT_PUBLIC_APP_URL}/candidate/applications/${applicationId}`\n      }\n\n      // Send confirmation email to candidate\n      await this.emailService.sendApplicationConfirmation(\n        application.users.email,\n        context\n      )\n\n      // Send alert to admin\n      const { data: adminUsers } = await this.supabase\n        .from('users')\n        .select('email')\n        .eq('tenant_id', application.jobs.tenant_id)\n        .eq('role', 'admin')\n\n      if (adminUsers && adminUsers.length > 0) {\n        for (const admin of adminUsers) {\n          await this.emailService.sendAdminApplicationAlert(\n            admin.email,\n            {\n              ...context,\n              adminUrl: `${process.env.NEXT_PUBLIC_APP_URL}/admin/applications/${applicationId}`\n            }\n          )\n        }\n      }\n    } catch (error) {\n      console.error('Error in onApplicationSubmitted:', error)\n    }\n  }\n\n  async onAssessmentRequired(applicationId: string) {\n    try {\n      const { data: application, error } = await this.supabase\n        .from('applications')\n        .select(`\n          *,\n          jobs (title, tenant_id),\n          users (first_name, last_name, email),\n          tenants (name)\n        `)\n        .eq('id', applicationId)\n        .single()\n\n      if (error || !application) {\n        console.error('Error fetching application for assessment email:', error)\n        return\n      }\n\n      const context = {\n        candidateName: `${application.users.first_name} ${application.users.last_name}`,\n        jobTitle: application.jobs.title,\n        companyName: application.tenants.name,\n        assessmentUrl: `${process.env.NEXT_PUBLIC_APP_URL}/candidate/applications/${applicationId}/assessment`\n      }\n\n      await this.emailService.sendAssessmentInvitation(\n        application.users.email,\n        context\n      )\n    } catch (error) {\n      console.error('Error in onAssessmentRequired:', error)\n    }\n  }\n\n  async onCandidateShortlisted(applicationId: string, aiScore: number) {\n    try {\n      const { data: application, error } = await this.supabase\n        .from('applications')\n        .select(`\n          *,\n          jobs (title, tenant_id),\n          users (first_name, last_name, email),\n          tenants (name)\n        `)\n        .eq('id', applicationId)\n        .single()\n\n      if (error || !application) {\n        console.error('Error fetching application for shortlist email:', error)\n        return\n      }\n\n      const context = {\n        candidateName: `${application.users.first_name} ${application.users.last_name}`,\n        jobTitle: application.jobs.title,\n        companyName: application.tenants.name,\n        aiScore: aiScore,\n        applicationUrl: `${process.env.NEXT_PUBLIC_APP_URL}/candidate/applications/${applicationId}`\n      }\n\n      await this.emailService.sendShortlistNotification(\n        application.users.email,\n        context\n      )\n    } catch (error) {\n      console.error('Error in onCandidateShortlisted:', error)\n    }\n  }\n\n  async onCandidateRejected(applicationId: string, reason?: string) {\n    try {\n      const { data: application, error } = await this.supabase\n        .from('applications')\n        .select(`\n          *,\n          jobs (title, tenant_id),\n          users (first_name, last_name, email),\n          tenants (name)\n        `)\n        .eq('id', applicationId)\n        .single()\n\n      if (error || !application) {\n        console.error('Error fetching application for rejection email:', error)\n        return\n      }\n\n      const context = {\n        candidateName: `${application.users.first_name} ${application.users.last_name}`,\n        jobTitle: application.jobs.title,\n        companyName: application.tenants.name,\n        reason: reason || 'We have decided to move forward with other candidates.',\n        applicationUrl: `${process.env.NEXT_PUBLIC_APP_URL}/candidate/applications/${applicationId}`\n      }\n\n      await this.emailService.sendRejectionNotification(\n        application.users.email,\n        context\n      )\n    } catch (error) {\n      console.error('Error in onCandidateRejected:', error)\n    }\n  }\n\n  async onMessageSent(messageId: string) {\n    try {\n      // Get message details\n      const { data: message, error } = await this.supabase\n        .from('messages')\n        .select(`\n          *,\n          applications (\n            id,\n            user_id,\n            jobs (title, tenant_id),\n            users (first_name, last_name, email),\n            tenants (name)\n          )\n        `)\n        .eq('id', messageId)\n        .single()\n\n      if (error || !message) {\n        console.error('Error fetching message for email notification:', error)\n        return\n      }\n\n      // Determine recipient (opposite of sender)\n      let recipientEmail: string\n      let candidateName: string\n\n      if (message.sender_id === message.applications.user_id) {\n        // Message from candidate to admin\n        const { data: adminUsers } = await this.supabase\n          .from('users')\n          .select('email')\n          .eq('tenant_id', message.applications.jobs.tenant_id)\n          .eq('role', 'admin')\n          .limit(1)\n\n        if (!adminUsers || adminUsers.length === 0) return\n        \n        recipientEmail = adminUsers[0].email\n        candidateName = `${message.applications.users.first_name} ${message.applications.users.last_name}`\n      } else {\n        // Message from admin to candidate\n        recipientEmail = message.applications.users.email\n        candidateName = `${message.applications.users.first_name} ${message.applications.users.last_name}`\n      }\n\n      const context = {\n        candidateName,\n        jobTitle: message.applications.jobs.title,\n        companyName: message.applications.tenants.name,\n        messageContent: message.content,\n        applicationUrl: `${process.env.NEXT_PUBLIC_APP_URL}/candidate/applications/${message.applications.id}`\n      }\n\n      await this.emailService.sendMessageNotification(\n        recipientEmail,\n        context\n      )\n    } catch (error) {\n      console.error('Error in onMessageSent:', error)\n    }\n  }\n\n  async onAssessmentScored(assessmentId: string) {\n    try {\n      // Get assessment and application details\n      const { data: assessment, error } = await this.supabase\n        .from('assessments')\n        .select(`\n          *,\n          applications (\n            id,\n            stage,\n            jobs (title, job_settings (shortlist_threshold)),\n            users (first_name, last_name, email)\n          )\n        `)\n        .eq('id', assessmentId)\n        .single()\n\n      if (error || !assessment) {\n        console.error('Error fetching assessment for email:', error)\n        return\n      }\n\n      const threshold = assessment.applications.jobs.job_settings?.shortlist_threshold || 75\n      \n      // If candidate was auto-shortlisted by AI, send shortlist notification\n      if (assessment.ai_total_score >= threshold && assessment.applications.stage === 'shortlisted') {\n        await this.onCandidateShortlisted(\n          assessment.applications.id,\n          assessment.ai_total_score\n        )\n      }\n    } catch (error) {\n      console.error('Error in onAssessmentScored:', error)\n    }\n  }\n\n  async sendBulkEmail(templateName: string, recipients: string[], context: any) {\n    try {\n      const promises = recipients.map(email => \n        this.emailService.sendTemplateEmail(\n          templateName,\n          email,\n          { ...context, recipientEmail: email }\n        )\n      )\n\n      await Promise.allSettled(promises)\n    } catch (error) {\n      console.error('Error in sendBulkEmail:', error)\n    }\n  }\n\n  async sendCustomEmail(to: string, subject: string, htmlContent: string, textContent?: string) {\n    try {\n      const emailService = new EmailService()\n      return await emailService['resend'].emails.send({\n        from: process.env.RESEND_FROM_EMAIL || 'noreply@atsplatform.com',\n        to,\n        subject,\n        html: htmlContent,\n        text: textContent || htmlContent.replace(/<[^>]*>/g, '')\n      })\n    } catch (error) {\n      console.error('Error sending custom email:', error)\n      throw error\n    }\n  }\n}"