import { NextRequest, NextResponse } from 'next/server'\nimport { createClient } from '@/lib/supabase/server'\nimport { getCurrentUser } from '@/lib/auth'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const user = await getCurrentUser()\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(request.url)\n    const applicationId = searchParams.get('application_id')\n    const limit = parseInt(searchParams.get('limit') || '50')\n    const offset = parseInt(searchParams.get('offset') || '0')\n\n    if (!applicationId) {\n      return NextResponse.json({ error: 'Application ID is required' }, { status: 400 })\n    }\n\n    const supabase = createClient()\n\n    // Verify user has access to this application\n    const { data: application } = await supabase\n      .from('applications')\n      .select('id, user_id, tenant_id')\n      .eq('id', applicationId)\n      .single()\n\n    if (!application) {\n      return NextResponse.json({ error: 'Application not found' }, { status: 404 })\n    }\n\n    // Check permissions\n    const hasAccess = user.role === 'admin' \n      ? application.tenant_id === user.tenant_id\n      : application.user_id === user.clerk_id\n\n    if (!hasAccess) {\n      return NextResponse.json({ error: 'Access denied' }, { status: 403 })\n    }\n\n    // Fetch messages\n    const { data: messages, error } = await supabase\n      .from('messages')\n      .select(`\n        *,\n        users (first_name, last_name, email)\n      `)\n      .eq('application_id', applicationId)\n      .order('created_at', { ascending: true })\n      .range(offset, offset + limit - 1)\n\n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 500 })\n    }\n\n    // Mark messages as read for the current user\n    if (messages && messages.length > 0) {\n      await supabase\n        .from('messages')\n        .update({ read_at: new Date().toISOString() })\n        .eq('application_id', applicationId)\n        .neq('sender_id', user.clerk_id)\n        .is('read_at', null)\n    }\n\n    return NextResponse.json({ messages: messages || [] })\n  } catch (error) {\n    console.error('Error fetching messages:', error)\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const user = await getCurrentUser()\n    if (!user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n\n    const { application_id, content, type = 'text' } = await request.json()\n\n    if (!application_id || !content?.trim()) {\n      return NextResponse.json(\n        { error: 'Application ID and content are required' },\n        { status: 400 }\n      )\n    }\n\n    const supabase = createClient()\n\n    // Verify user has access to this application\n    const { data: application } = await supabase\n      .from('applications')\n      .select('id, user_id, tenant_id')\n      .eq('id', application_id)\n      .single()\n\n    if (!application) {\n      return NextResponse.json({ error: 'Application not found' }, { status: 404 })\n    }\n\n    // Check permissions\n    const hasAccess = user.role === 'admin' \n      ? application.tenant_id === user.tenant_id\n      : application.user_id === user.clerk_id\n\n    if (!hasAccess) {\n      return NextResponse.json({ error: 'Access denied' }, { status: 403 })\n    }\n\n    // Create message\n    const { data: message, error } = await supabase\n      .from('messages')\n      .insert({\n        application_id,\n        sender_id: user.clerk_id,\n        content: content.trim(),\n        type,\n        created_at: new Date().toISOString()\n      })\n      .select(`\n        *,\n        users (first_name, last_name, email)\n      `)\n      .single()\n\n    if (error) {\n      return NextResponse.json({ error: error.message }, { status: 500 })\n    }\n\n    // Update application's last activity\n    await supabase\n      .from('applications')\n      .update({ updated_at: new Date().toISOString() })\n      .eq('id', application_id)\n\n    // TODO: Send email notification to the other party\n    // This would be implemented with the Resend integration\n\n    return NextResponse.json({ message })\n  } catch (error) {\n    console.error('Error sending message:', error)\n    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })\n  }\n}"